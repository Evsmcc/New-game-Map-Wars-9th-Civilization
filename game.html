<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Map Wars: 9th Civilization</title>
</head>
<body>
    <div class="game-container">
        <!-- å·¦ä¾§ä¿¡æ¯æ  -->
        <aside class="sidebar left-sidebar">
            <div class="sidebar-top">
                <h1>Civilization IX</h1>
                <div class="language-select" style="margin-bottom: 15px; display: flex; gap: 5px;">
                    <button class="lang-btn" data-lang="zh">ä¸­æ–‡</button>
                    <button class="lang-btn active" data-lang="en">EN</button>
                </div>
                <div class="game-stats">
                    <div class="stat-item">
                        <span class="label">Current Turn</span>
                        <span id="current-player-name" class="value p1">Player 1</span>
                    </div>
                    <div class="stat-item">
                        <span class="label">Round</span>
                        <span id="round-number" class="value">1</span>
                    </div>
                    <div class="stat-item">
                        <span class="label">Deck</span>
                        <span id="deck-count" class="value">0</span>
                    </div>
                </div>
            </div>
            
            <div class="player-scores">
                <div class="score-card p1">
                    <span class="player-label">Black Score:</span>
                    <span id="p1-score" class="score-value">0</span>
                </div>
                <div class="score-card p2">
                    <span class="player-label">White Score:</span>
                    <span id="p2-score" class="score-value">0</span>
                </div>
            </div>

            <div class="sidebar-bottom">
                <div class="ai-control" style="margin-bottom: 10px; padding: 10px; background: #f8f9fa; border-radius: 8px; border: 1px solid #ddd;">
                    <label style="display: flex; align-items: center; cursor: pointer; font-size: 0.9rem; color: #333;">
                        <input type="checkbox" id="ai-toggle" style="margin-right: 8px; width: 16px; height: 16px;" checked>
                        AI Control White Player
                    </label>
                </div>
                <button id="rules-btn" class="btn primary" style="width: 100%; margin-bottom: 8px;">Rules</button>
                <button id="restart-btn" class="btn secondary" style="width: 100%;">Restart</button>
            </div>
        </aside>

        <!-- æ¸¸æˆè¯´æ˜æ¨¡æ€æ¡† -->
        <div id="rules-modal" class="modal hidden">
            <div class="modal-content rules-modal-content">
                <span class="close-btn" id="rules-modal-close">&times;</span>
                <div class="rules-scroll-area">
                    <h1>ğŸ“œ Civilization IX Manual</h1>
                    <p><strong>Civilization IX</strong> is a 2-player abstract strategy game combining space occupation and hand management.</p>
                    
                    <div class="rules-story">
                        <p>Background:</p>
                        <ul>
                            <li>Board: Territory</li>
                            <li>Yellow: Plains</li>
                            <li>Green: Forest</li>
                            <li>Blue: River</li>
                            <li>Brown: Mountain</li>
                            <br>
                            <li>Yellow Card: Plains Civ</li>
                            <li>Green Card: Forest Civ</li>
                            <li>Blue Card: River Civ</li>
                            <li>Brown Card: Mountain Civ</li>
                            <li>Red Card: War Civ</li>
                        </ul>
                    </div>

                    <hr>

                    <h3>1. Components</h3>
                    <ul>
                        <li><strong>Star Map (Board)</strong>: 10x10 grid with four base colors (Yellow, Brown, Blue, Green). Some cells have base values of 1-3.</li>
                        <li><strong>Civilization (Hand)</strong>:
                            <ul>
                                <li><strong>Build Cards</strong>: Yellow/Green (1-9), Blue (1-5), Brown (5-9).</li>
                                <li><strong>Attack Cards (Red)</strong>: Values 5-9, with special "Overdrive" ability.</li>                               
                            </ul>
                        </li>
                    </ul>

                    <hr>

                    <h3>2. Setup</h3>
                    <ul>
                        <li>Each player draws <strong>11 cards</strong> at the start.</li>
                        <li>Player 1 (Black) starts first, followed by Player 2 (White).</li>
                        <li>At the start of each turn, the current player automatically draws 2 cards.</li>
                    </ul>

                    <hr>

                    <h3>3. Turn Flow</h3>
                    <p>During each turn, you can:</p>
                    
                    <h4>A. Build Civilization (Place Card)</h4>
                    <p>Place <strong>at most 1 card</strong> per turn. Placement must follow one of these rules:</p>
                    <ol>
                        <li><strong>Initial</strong>: Match card color and cell color, and value.</li>
                        <li><strong>Expansion</strong>: Match color. Must be adjacent to your existing piece. Value must be same or adjacent (Â±1).</li>
                        <li><strong>Overdrive (Cover)</strong>: <strong>Red cards only</strong>. Can cover opponent's piece if:
                            <ul>
                                <li>Red card value is <strong>higher</strong> than opponent's piece.</li>
                                <li>Must be adjacent to your existing piece with same or adjacent (Â±1) value.</li>
                            </ul>
                        </li>
                    </ol>

                    <h4>B. Resource Recycling (Discard)</h4>
                    <ul>
                        <li>Drag 1 card (or 2 if no card was placed) to the "Discard" area.</li>
                        <li>Discard area shows the last recycled card.</li>
                    </ul>

                    <h4>ğŸ Turn End</h4>
                    <ul>
                        <li>Turn ends when your hand size is <strong>â‰¤ 11 cards</strong>.</li>
                        <li><em>Note: If you placed a card, discard 1. If not, discard 2 to reach â‰¤ 11.</em></li>
                    </ul>

                    <hr>

                    <h3>4. Scoring</h3>
                    <p>Game ends when <strong>both players have no cards</strong>. Points are then calculated.</p>
                    
                    <h4>Chain Scoring Rule:</h4>
                    <ul>
                        <li>Connected pieces (Up, Down, Left, Right) form a "Civilization Chain".</li>
                        <li><strong>Ladder Check</strong>: A piece scores only if the chain contains <strong>all values smaller than it</strong>.
                            <ul>
                                <li><em>Example: A value 4 piece scores only if values 1, 2, and 3 exist in the same chain.</em></li>
                            </ul>
                        </li>
                        <li>If valid, the piece value is added to your score; otherwise, it scores 0.</li>
                    </ul>

                    <hr>

                    <h3>5. Victory</h3>
                    <ul>
                        <li>The player with the highest total score wins. Ties are possible.</li>
                    </ul>
                </div>
            </div>
        </div>

        <!-- ä¸­é—´ä¸»åŒºåŸŸ -->
        <main class="game-main">
            <!-- Player 2 Hand (Top) -->
            <div class="player-area" id="player2-area">
                <div class="hand-container horizontal-hand-container">
                    <div class="hand-info-mini">
                        <span class="hand-label">White Player 2 Hand</span>
                        <span id="p2-hand-count" class="count-badge">7</span>
                    </div>
                    <div class="hand horizontal-hand" id="p2-hand"></div>
                </div>
            </div>

            <!-- æ£‹ç›˜ä¸ç´§é çš„ä¸¢å¼ƒåŒº -->
            <div class="middle-section">
                <div class="board-main">
                    <div class="board-container">
                        <div id="board" class="board"></div>
                    </div>
                    
                    <!-- ä¸¢å¼ƒåŒºç´§é æ£‹ç›˜å³ä¾§ -->
                    <aside class="right-panel">
                        <div id="discard-square" class="discard-square">
                            <span class="discard-label">Discard</span>
                            <div id="discard-content" class="discard-content"></div>
                        </div>
                    </aside>
                </div>
            </div>

            <!-- Player 1 Hand (Bottom) -->
            <div class="player-area" id="player1-area">
                <div class="hand-container horizontal-hand-container">
                    <div class="hand-info-mini">
                        <span class="hand-label">Black Player 1 Hand</span>
                        <span id="p1-hand-count" class="count-badge">7</span>
                    </div>
                    <div class="hand horizontal-hand" id="p1-hand"></div>
                </div>
            </div>
        </main>

        <!-- Rules Sidebar -->
        <aside class="rules-sidebar">
            <div class="game-rules">
                <section class="rules-section">
                    <h3>Turn Flow</h3>
                    <ol>
                        <li>Draw 2 cards</li>
                        <li>Place 1 card (optional)</li>
                        <li>Discard until hand â‰¤ 11</li>
                    </ol>
                </section>

                <section class="rules-section">
                    <h3>Placement</h3>
                    <ul>
                        <li><strong>Initial</strong>: Match color & value.</li>
                        <li><strong>Expansion</strong>: Adjacent, value same or Â±1, match color.</li>
                        <li><strong>Overdrive</strong>: Red only. Value > opponent, and must be adjacent to your existing piece with same or adjacent (Â±1) value.</li>
                    </ul>
                </section>

                <section class="rules-section">
                    <h3>Scoring</h3>
                    <ul>
                        <li>Sum of valid piece values.</li>
                        <li><strong>Valid</strong>: Chain must contain all smaller values.</li>
                    </ul>
                </section>

                <section class="rules-section">
                    <h3>Game End</h3>
                    <p>Game ends when both players have no cards.</p>
                </section>
            </div>
        </aside>
    </div>
    
    <!-- Modal: Game Over or Other Alerts -->
    <div id="message-modal" class="modal hidden">
        <div class="modal-content">
            <p id="modal-text"></p>
            <button id="modal-close-btn">Close</button>
        </div>
    </div>

</body>
</html>
<style>
:root {
    --bg-color: #f0f2f5;
    --board-bg: #eecfa1; /* æœ¨çº¹è‰²ï¼ˆé»˜è®¤ï¼Œå¯èƒ½è¢«è¦†ç›–ï¼‰ */
    --grid-line: #8b4513;
    --p1-color: #333; /* é»‘æ£‹ */
    --p2-color: #fff; /* ç™½æ£‹ */
    --highlight-color: #4caf50;
    --selected-color: #ffeb3b;
    
    /* æ ¼å­é¢œè‰²å®šä¹‰ */
    --cell-yellow: #fff59d;
    --cell-brown: #bcaaa4;
    --cell-blue: #90caf9;
    --cell-green: #a5d6a7;
    
    /* å¡ç‰Œé¢œè‰²å®šä¹‰ï¼ˆç¨å¾®æ·±ä¸€ç‚¹ä»¥ä¾¿çœ‹æ¸…æ–‡å­—ï¼‰ */
    --card-yellow: #fdd835;
    --card-brown: #8d6e63;
    --card-blue: #64b5f6;
    --card-green: #81c784;
    --card-red: #e57373;
}

* {
    box-sizing: border-box;
    margin: 0;
    padding: 0;
}

body {
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    background-color: var(--bg-color);
    display: flex;
    justify-content: center;
    height: 100vh; /* å æ»¡å…¨å±é«˜åº¦ */
    overflow: hidden; /* ç¦æ­¢æ»šåŠ¨ */
    padding: 10px;
}

.game-container {
    display: flex;
    flex-direction: row; 
    align-items: stretch;
    gap: 10px;
    max-width: 1400px;
    width: 100%;
    height: 100%; 
    padding: 10px;
    margin: 0 auto;
}

/* å·¦ä¾§ä¿¡æ¯æ  */
.left-sidebar {
    width: 220px;
    background: white;
    padding: 12px;
    border-radius: 12px;
    box-shadow: 2px 0 10px rgba(0,0,0,0.05);
    display: flex;
    flex-direction: column;
    gap: 12px;
    flex-shrink: 0;
}

.sidebar-top h1 {
    font-size: 1.4rem;
    margin-bottom: 15px;
    color: #2c3e50;
    border-bottom: 2px solid #eee;
    padding-bottom: 10px;
}

.game-stats {
    display: flex;
    flex-direction: column;
    gap: 12px;
}

.stat-item {
    display: flex;
    justify-content: space-between;
    align-items: center;
    font-size: 0.95em;
}

.stat-item .label {
    color: #666;
}

.stat-item .value {
    font-weight: bold;
    padding: 2px 8px;
    border-radius: 4px;
}

.stat-item .value.p1 { background-color: #333; color: white; }
.stat-item .value.p2 { background-color: #f0f0f0; color: #333; border: 1px solid #ccc; }

.player-scores {
    display: flex;
    flex-direction: column;
    gap: 10px;
}

.score-card {
    padding: 12px;
    border-radius: 8px;
    display: flex;
    justify-content: space-between;
    align-items: center;
}

.score-card.p1 { background-color: #333; color: white; }
.score-card.p2 { background-color: #f0f0f0; color: #333; border: 1px solid #ccc; }

.score-value {
    font-size: 1.5rem;
    font-weight: bold;
}

.sidebar-bottom {
    margin-top: auto;
}

/* ä¸»æ¸¸æˆåŒºåŸŸï¼ˆæ‰‹ç‰Œ-ä¸­é—´åŒº-æ‰‹ç‰Œï¼‰ */
.game-main {
    flex: 1;
    display: flex;
    flex-direction: column;
    gap: 5px;
    min-width: 0;
    height: 100%;
    overflow: hidden; /* é˜²æ­¢å†…å®¹æº¢å‡ºå¯¼è‡´çˆ¶å…ƒç´ å˜å½¢ */
}

.player-area {
    width: 100%;
    background: white;
    padding: 4px 10px;
    border-radius: 8px;
    box-shadow: 0 2px 4px rgba(0,0,0,0.05);
    flex-shrink: 0;
}

.hand-container {
    display: flex;
    align-items: center;
    gap: 10px;
}

.hand-info-mini {
    display: flex;
    flex-direction: column;
    align-items: center;
    min-width: 80px;
}

.hand-label {
    font-size: 0.75em;
    color: #666;
    font-weight: bold;
}

.count-badge {
    background: #e9ecef;
    padding: 1px 6px;
    border-radius: 10px;
    font-size: 0.8em;
    font-weight: bold;
    color: #333;
}

.hand {
    flex: 1;
    display: flex;
    flex-wrap: nowrap;
    overflow-x: auto;
    gap: 6px;
    padding: 4px;
    background: #f8f9fa;
    border-radius: 6px;
    min-height: 48px;
    align-items: center;
    border: 1px inset #eee;
    scrollbar-width: none;
}

.hand::-webkit-scrollbar {
    display: none;
}

.card {
    width: 38px;
    height: 38px;
    border-radius: 6px;
    border: 2px solid #ccc;
    display: flex;
    justify-content: center;
    align-items: center;
    cursor: pointer;
    user-select: none;
    font-size: 1em;
    font-weight: bold;
    color: #fff;
    text-shadow: 1px 1px 1px rgba(0,0,0,0.3);
    transition: all 0.2s;
    flex-shrink: 0;
}

/* å¡ç‰Œé¢œè‰² */
.card.yellow { background-color: var(--card-yellow); color: #333; text-shadow: none; }
.card.brown { background-color: var(--card-brown); }
.card.blue { background-color: var(--card-blue); }
.card.green { background-color: var(--card-green); }
.card.red { background-color: var(--card-red); }

.card.selected {
    transform: scale(1.15);
    box-shadow: 0 0 8px var(--selected-color);
    border-color: var(--selected-color) !important;
    z-index: 10;
}

/* Board */
.middle-section {
    flex: 1;
    display: flex;
    flex-direction: row;
    gap: 5px;
    min-height: 0;
    min-width: 0; /* å…è®¸å†…éƒ¨å…ƒç´ æ ¹æ®æ¯”ä¾‹æ”¶ç¼© */
}

.board-main {
    flex: 1;
    background: white;
    padding: 15px;
    border-radius: 12px;
    box-shadow: 0 4px 6px rgba(0,0,0,0.05);
    display: flex;
    flex-direction: row;
    justify-content: center;
    align-items: center;
    min-height: 0;
    min-width: 0; /* å…³é”®ï¼šå…è®¸ board-main ç¼©å°ä»¥é€‚åº”æ¯”ä¾‹è®¡ç®— */
    gap: 15px;
}

.board-container {
    /* ä½¿ç”¨ vmin æ–¹æ¡ˆï¼šæ— è®ºçª—å£å¦‚ä½•å˜åŒ–ï¼Œæ£‹ç›˜å§‹ç»ˆä»¥è§†å£è¾ƒå°è¾¹çš„ 65% ä½œä¸ºåŸºå‡†ï¼Œ
       è¿™æ ·åœ¨æ‰€æœ‰æµè§ˆå™¨ä¸­éƒ½èƒ½ä¿è¯ç»å¯¹çš„æ­£æ–¹å½¢ï¼Œä¸”ä¸ä¼šè¢«çˆ¶å®¹å™¨å®½åº¦é™åˆ¶æ­» */
    height: 65vmin; 
    width: 65vmin;
    max-height: calc(100vh - 250px);
    max-width: calc(100% - 140px);
    aspect-ratio: 1 / 1;
    flex: 0 0 auto;
    display: block;
    position: relative;
}

.board {
    display: grid;
    grid-template-columns: repeat(10, 1fr);
    grid-template-rows: repeat(10, 1fr);
    gap: 1px;
    background-color: var(--grid-line);
    border: 2px solid var(--grid-line);
    width: 100%;
    height: 100%;
}

.right-panel {
    width: 125px;
    display: flex;
    flex-direction: column;
    gap: 10px;
    flex-shrink: 0;
    justify-content: center;
}

.rules-sidebar {
    width: 260px;
    background: white;
    padding: 12px;
    border-radius: 12px;
    box-shadow: -2px 0 10px rgba(0,0,0,0.05);
    display: flex;
    flex-direction: column;
    flex-shrink: 0;
    height: 100%;
}

.game-rules {
    height: 100%;
    display: flex;
    flex-direction: column;
    justify-content: space-between; /* å‡åŒ€åˆ†å¸ƒè§„åˆ™æ®µè½ */
    font-size: 0.82rem;
    color: #444;
    line-height: 1.35;
}

.rules-section {
    margin-bottom: 8px;
}

.rules-section:last-child {
    margin-bottom: 0;
}

.rules-section h3 {
    font-size: 0.9rem;
    color: #2c3e50;
    margin-bottom: 4px;
    padding-bottom: 2px;
    border-bottom: 1px solid #eee;
    display: flex;
    align-items: center;
}

.rules-section h3::before {
    content: 'â—ˆ';
    margin-right: 6px;
    color: #8b4513;
    font-size: 0.75rem;
}

.rules-section ul, .rules-section ol {
    padding-left: 16px;
}

.rules-section li {
    margin-bottom: 2px;
}

.rules-section strong {
    color: #d32f2f;
}

.discard-container {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    height: 100%;
}

.discard-square {
    width: 120px;
    height: 120px;
    border: 3px dashed #8b4513;
    border-radius: 12px;
    background-color: rgba(139, 69, 19, 0.1);
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    transition: all 0.3s;
    position: relative;
}

.discard-square:hover {
    background-color: rgba(139, 69, 19, 0.2);
    transform: scale(1.05);
}

.discard-label {
    font-size: 0.9em;
    font-weight: bold;
    color: #8b4513;
    margin-bottom: 5px;
    pointer-events: none;
}

.discard-content {
    width: 60px;
    height: 60px;
    display: flex;
    justify-content: center;
    align-items: center;
}

.discard-content .card {
    transform: scale(1.5);
    cursor: default;
}

.cell {
    position: relative;
    cursor: pointer;
    width: 100%;
    height: 100%;
    display: flex;
    justify-content: center;
    align-items: center;
}

/* é¢œè‰²æ ·å¼ */
.cell.yellow { background-color: var(--cell-yellow); }
.cell.brown { background-color: var(--cell-brown); }
.cell.blue { background-color: var(--cell-blue); }
.cell.green { background-color: var(--cell-green); }

.cell:hover {
    filter: brightness(0.9);
}

.cell.has-piece {
    cursor: default;
}

/* åˆæ³•ä½ç½®é«˜äº® */
.cell.highlight-valid::after {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background-color: rgba(255, 255, 255, 0.3);
    box-shadow: inset 0 0 0 4px #3406b1, inset 0 0 20px rgba(198, 8, 11, 0.8);
    z-index: 3;
    pointer-events: none;
    animation: pulse-highlight 1s infinite ease-in-out;
}

/* æœ€åè½å­ä½ç½®é«˜äº® */
.cell.last-move::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    border: 3px solid #ff4444; /* æ˜¾çœ¼çš„çº¢è‰²è¾¹æ¡† */
    background-color: rgba(255, 68, 68, 0.15); /* æ·¡æ·¡çš„çº¢åº• */
    z-index: 4;
    pointer-events: none;
    box-shadow: 0 0 10px rgba(255, 68, 68, 0.5);
}

@keyframes pulse-highlight {
    0% { opacity: 0.6; transform: scale(1); }
    50% { opacity: 1; transform: scale(0.98); }
    100% { opacity: 0.6; transform: scale(1); }
}

.cell-number {
    font-size: 1.2rem;
    font-weight: bold;
    color: rgba(0, 0, 0, 0.25); /* åŠé€æ˜é»‘è‰²ï¼Œé¿å…å¹²æ‰°æ£‹å­è§†è§‰ */
    user-select: none;
    z-index: 1;
}

/* ç§»åŠ¨ç«¯å­—ä½“è°ƒæ•´ */
@media (max-width: 600px) {
    .cell-number {
        font-size: 0.9rem;
    }
}

.piece {
    width: 90%;
    height: 90%;
    border-radius: 6px; /* ç±»ä¼¼å¡ç‰Œçš„åœ†è§’ */
    position: absolute;
    top: 5%;
    left: 5%;
    z-index: 2; /* ç¡®ä¿åœ¨æ•°å­—ä¹‹ä¸Š */
    display: flex;
    justify-content: center;
    align-items: center;
    font-weight: bold;
    font-size: 1.1em;
    color: white; /* é»˜è®¤æ–‡å­—é¢œè‰² */
    text-shadow: 1px 1px 1px rgba(0,0,0,0.3);
    border-width: 3px;
    border-style: solid;
    box-shadow: 0 2px 4px rgba(0,0,0,0.2);
}

/* æ£‹å­é¢œè‰²ï¼ˆå¯¹åº”æ‰‹ç‰Œé¢œè‰²ï¼‰- ä»…ä½œä¸ºæ–‡å­—é¢œè‰²æˆ–è¾¹æ¡†é¢œè‰²çš„å‚è€ƒï¼ŒèƒŒæ™¯ç”±ç©å®¶å½’å±å†³å®š */
/* 
.piece.yellow { background-color: var(--card-yellow); color: #333; text-shadow: none; }
.piece.brown { background-color: var(--card-brown); }
.piece.blue { background-color: var(--card-blue); }
.piece.green { background-color: var(--card-green); }
*/

/* åŒºåˆ†ä¸¤å®¶è½å­å½’å±ï¼ˆé€šè¿‡èƒŒæ™¯é¢œè‰²å’Œè¾¹æ¡†ï¼‰ */
.piece.p1 {
    background-color: #333; /* ç©å®¶1 æ·±è‰²èƒŒæ™¯ */
    color: #fff;            /* ç™½è‰²æ–‡å­— */
    border-color: #000;     /* é»‘è‰²è¾¹æ¡† */
}

.piece.p2 {
    background-color: #f0f0f0; /* ç©å®¶2 æµ…è‰²èƒŒæ™¯ */
    color: #000;               /* é»‘è‰²æ–‡å­— */
    border-color: #fff;        /* ç™½è‰²è¾¹æ¡† */
}

/* å¦‚æœæƒ³ä¿ç•™åŸæ¥çš„é¢œè‰²ä¿¡æ¯ï¼Œå¯ä»¥ç”¨æ–‡å­—é¢œè‰²æ¥åŒºåˆ† */
.piece.p1.yellow { color: var(--card-yellow); }
.piece.p1.brown { color: var(--card-brown); }
.piece.p1.blue { color: var(--card-blue); }
.piece.p1.green { color: var(--card-green); }
.piece.p1.red { color: var(--card-red); }

/* å¯¹äºæµ…è‰²èƒŒæ™¯çš„P2ï¼Œé¢œè‰²å¯èƒ½éœ€è¦è°ƒæ•´æ·±ä¸€ç‚¹ä»¥ä¿è¯å¯¹æ¯”åº¦ï¼Œæˆ–è€…ç›´æ¥ç”¨åŸè‰² */
.piece.p2.yellow { color: #fbc02d; /* æ·±ä¸€ç‚¹çš„é»„ */ }
.piece.p2.brown { color: #795548; /* åŸæ£•è‰² */ }
.piece.p2.blue { color: #1976d2; /* åŸè“è‰² */ }
.piece.p2.green { color: #388e3c; /* åŸç»¿è‰² */ }
.card.ai-hidden {
    background: linear-gradient(135deg, #607d8b 25%, #546e7a 25%, #546e7a 50%, #607d8b 50%, #607d8b 75%, #546e7a 75%, #546e7a 100%);
    background-size: 20px 20px;
    color: rgba(255,255,255,0.5);
    border: 2px solid #455a64;
    cursor: default;
}

.lang-btn {
    flex: 1;
    padding: 4px 8px;
    font-size: 0.8rem;
    border: 1px solid #ddd;
    background: #f8f9fa;
    cursor: pointer;
    border-radius: 4px;
    transition: all 0.2s;
}

.lang-btn.active {
    background: #2c3e50;
    color: white;
    border-color: #2c3e50;
}

.lang-btn:hover:not(.active) {
    background: #e9ecef;
}

/* Modal */
.modal {
    position: fixed;
    top: 0; left: 0; width: 100%; height: 100%;
    background: rgba(0,0,0,0.5);
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 100;
}

.modal.hidden {
    display: none;
}

.modal-content {
    background: white;
    padding: 20px;
    border-radius: 8px;
    text-align: center;
    box-shadow: 0 4px 12px rgba(0,0,0,0.15);
}

/* æ¸¸æˆè¯´æ˜æ¨¡æ€æ¡†ç‰¹æœ‰æ ·å¼ */
.rules-modal-content {
    max-width: 800px;
    width: 90%;
    max-height: 85vh;
    display: flex;
    flex-direction: column;
    text-align: left;
    position: relative;
    padding: 30px;
}

.rules-scroll-area {
    overflow-y: auto;
    padding-right: 15px;
}

.rules-scroll-area h1 {
    font-size: 1.8rem;
    margin-bottom: 20px;
    color: #2c3e50;
    text-align: center;
}

.rules-scroll-area h3 {
    margin: 20px 0 10px 0;
    color: #2c3e50;
    border-left: 4px solid #4caf50;
    padding-left: 10px;
}

.rules-scroll-area h4 {
    margin: 15px 0 8px 0;
    color: #34495e;
}

.rules-scroll-area p {
    margin-bottom: 10px;
    line-height: 1.6;
    color: #444;
}

.rules-scroll-area ul, .rules-scroll-area ol {
    margin-bottom: 15px;
    padding-left: 25px;
    line-height: 1.6;
    color: #444;
}

.rules-scroll-area li {
    margin-bottom: 5px;
}

.rules-scroll-area hr {
    margin: 25px 0;
    border: 0;
    border-top: 1px solid #eee;
}

.rules-story {
    background: #f9f9f9;
    padding: 15px;
    border-radius: 8px;
    font-size: 0.9rem;
    color: #666;
    margin-bottom: 20px;
}

.rules-story ul {
    list-style: none;
    padding-left: 0;
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 5px;
}

.close-btn {
    position: absolute;
    top: 15px;
    right: 20px;
    font-size: 28px;
    cursor: pointer;
    color: #aaa;
    transition: color 0.2s;
}

.close-btn:hover {
    color: #333;
}

/* Responsive tweaks for very small screens */
@media (max-height: 600px) {
    header { padding: 5px 10px; }
    header h1 { font-size: 1rem; }
    .player-area { padding: 5px; }
    .card { width: 30px; height: 30px; font-size: 0.8em; }
    .hand { min-height: 40px; }
}

</style>
<script>
// æ¸¸æˆå¸¸é‡
const BOARD_SIZE = 10;
const INITIAL_HAND_SIZE = 11;
const CELL_COLORS = ['yellow', 'brown', 'blue', 'green'];
const CARD_COLORS = ['yellow', 'brown', 'blue', 'green', 'red'];

// æ¸¸æˆçŠ¶æ€
let state = {
    currentLang: 'en',
    board: [],
    currentPlayer: 1,
    round: 1,
    selectedCardIndex: null,
    discardedCard: null,
    lastMove: null, // æ–°å¢ï¼šè®°å½•æœ€åä¸€æ¬¡è½å­çš„ä½ç½® {row, col}
    gameActive: true,
    placedThisTurn: false, // æ–°å¢ï¼šè®°å½•æœ¬å›åˆæ˜¯å¦å·²æ”¾ç½®æ£‹å­
    isAIEnabled: true, // æ–°å¢ï¼šæ˜¯å¦å¼€å¯AIæ‰˜ç®¡
    deck: [], // æ–°å¢ç‰Œå †
    players: {
        1: { name: 'ç©å®¶ 1 é»‘è‰²', hand: [] },
        2: { name: 'ç©å®¶ 2 ç™½è‰²', hand: [] }
    },
    aiPlannedCardIndex: null // è®°å½•æå¤§æå°æ³•é€‰ä¸­çš„æœ€ä½³è½å­æ‰‹ç‰Œç´¢å¼•
};

// å¤šè¯­è¨€é…ç½®
const i18n = {
    zh: {
        gameTitle: "ã€Š ä¹é˜¶æ–‡æ˜ ã€‹",
        currentPlayer: "å½“å‰å›åˆ",
        p1Name: "ç©å®¶ 1",
        p2Name: "ç©å®¶ 2",
        round: "å›åˆæ•°",
        deckRemaining: "ç‰Œå †å‰©ä½™",
        p1ScoreLabel: "é»‘æ£‹ç©å®¶å¾—åˆ†ï¼š",
        p2ScoreLabel: "ç™½æ£‹ç©å®¶å¾—åˆ†ï¼š",
        aiControl: "ç”µè„‘æ‰˜ç®¡ç™½è‰²ç©å®¶",
        rulesBtn: "æ¸¸æˆè¯´æ˜",
        restartBtn: "é‡æ–°å¼€å§‹",
        p1HandLabel: "é»‘è‰²ç©å®¶ 1 æ‰‹ç‰Œ",
        p2HandLabel: "ç™½è‰²ç©å®¶ 2 æ‰‹ç‰Œ",
        discardLabel: "ä¸¢å¼ƒåŒº",
        modalClose: "å…³é—­",
        gameOverTitle: "æ¸¸æˆç»“æŸï¼",
        p1Win: "ç©å®¶ 1 (é»‘æ£‹) è·èƒœï¼",
        p2Win: "ç©å®¶ 2 (ç™½æ£‹) è·èƒœï¼",
        draw: "å¹³å±€ï¼",
        scoreDetail: "æœ€ç»ˆå¾—åˆ† - é»‘æ£‹: {s1}, ç™½æ£‹: {s2}",
        alertPlaced: "æœ¬å›åˆå·²ç»æ”¾ç½®è¿‡æ£‹å­äº†ï¼Œè¯·ä¸¢å¼ƒæ‰‹ç‰Œä»¥ç»“æŸå›åˆã€‚",
        alertSelectCard: "è¯·å…ˆé€‰æ‹©ä¸€å¼ æ‰‹ç‰Œï¼",
        alertRedOnly: "è¦†ç›–å¤±è´¥ï¼åªæœ‰çº¢è‰²æ‰‹ç‰Œå¯ä»¥è¦†ç›–å¯¹æ‰‹çš„æ£‹å­ã€‚",
        alertRedHigher: "è¦†ç›–å¤±è´¥ï¼çº¢è‰²æ‰‹ç‰Œæ•°å€¼ ({v1}) å¿…é¡»é«˜äºå¯¹æ–¹çš„ç‰Œæ•°å€¼ ({v2})ã€‚",
        alertRedSupport: "è¦†ç›–å¤±è´¥ï¼è¦æ±‚ç›®æ ‡æ ¼å››å‘¨æœ‰å·±æ–¹ä¸”æ•°å€¼ç›¸åŒæˆ–ç›¸é‚»çš„æ£‹å­ã€‚",
        alertInvalidMove: "è½å­å¤±è´¥ï¼è¯·æ£€æŸ¥ï¼š\n1. æ˜¯å¦é¢œè‰²ç›¸åŒä¸”æ•°å€¼åŒ¹é… (é’ˆå¯¹1-3åˆ†æ ¼å­)\n2. æ˜¯å¦é¢œè‰²ç›¸åŒä¸”ç›¸é‚»æœ‰æ•°å€¼ç›¸åŒæˆ–ç›¸é‚»çš„å·±æ–¹æ£‹å­\n3. çº¢è‰²æ‰‹ç‰Œè¦†ç›–å¯¹æ–¹æ£‹å­éœ€æ•°å€¼æ›´é«˜ä¸”ç›¸é‚»æœ‰å·±æ–¹æ£‹å­",
        rulesHtml: `
            <h1>ğŸ“œ ã€Šä¹é˜¶æ–‡æ˜ã€‹æ¸¸æˆè¯´æ˜ä¹¦</h1>
            <p><strong>ã€Šä¹é˜¶æ–‡æ˜ã€‹</strong> æ˜¯ä¸€æ¬¾èåˆäº†ç©ºé—´å é¢†ã€æ•°å€¼åšå¼ˆä¸æ‰‹ç‰Œç®¡ç†çš„åŒäºº(æˆ–å¤šäºº)æŠ½è±¡ç­–ç•¥æ¸¸æˆã€‚</p>
            <div class="rules-story">
                <p>é¢œè‰²ä»£è¡¨ï¼šé»„è‰²-å¹³åŸ, ç»¿è‰²-æ£®æ—, è“è‰²-æ²³æµ, æ£•è‰²-å±±å·, çº¢è‰²-æˆ˜äº‰</p>
            </div>
            <hr>
            <h3>1. æ¸¸æˆç»„ä»¶</h3>
            <ul>
                <li><strong>æ˜Ÿå›¾ (æ£‹ç›˜)</strong>ï¼š10x10 ç½‘æ ¼ï¼Œå››ç§åŸºç¡€é¢œè‰²ã€‚</li>
                <li><strong>æ–‡æ˜åºåˆ— (æ‰‹ç‰Œ)</strong>ï¼š8ç»„é»„ç‰Œ (1-9)ã€4ç»„ç»¿ç‰Œ (1-9)ã€4ç»„è“ç‰Œ (1-5)ã€4ç»„æ£•ç‰Œ (5-9)   ã€2ç»„çº¢è‰² (5-9)ã€‚</li>
            </ul>
            <hr>
            <h3>2. å›åˆæµç¨‹</h3>
            <p>1. æŠ“2å¼ ç‰Œï¼›2. æ”¾ç½®æœ€å¤š1å¼ ç‰Œï¼›3. å¼ƒç‰Œè‡³æ‰‹ç‰Œ â‰¤ 11å¼ ã€‚</p>
            <hr>
            <h3>3. è½å­è§„åˆ™</h3>
            <ul>
                <li><strong>åˆå§‹å é¢†</strong>ï¼šé¢œè‰²ä¸æ•°å€¼å‡åŒ¹é…ã€‚</li>
                <li><strong>æ‰©å¼ è¿é€š</strong>ï¼šæ”¾ç½®åœ¨å·±æ–¹å››å‘¨ï¼Œæ•°å€¼ç›¸åŒæˆ–ç›¸é‚»(Â±1)ã€‚</li>
                <li><strong>é™ç»´è¦†ç›–</strong>ï¼šçº¢è‰²ç‰Œå¯è¦†ç›–å¯¹æ‰‹ï¼Œéœ€æ•°å€¼æ›´å¤§ä¸”å››å‘¨æœ‰å·±æ–¹æ”¯æ’‘ã€‚</li>
            </ul>
            <hr>
            <h3>4. å¾—åˆ†ä¸ç»“ç®—</h3>
            <p><strong>è¿é€šå—æ³•åˆ™</strong>ï¼šè¿é€šå—å†…å¿…é¡»åŒ…å«æ¯”è¯¥æ£‹å­å°çš„æ‰€æœ‰æ•°å€¼æ‰èƒ½å¾—åˆ†ã€‚</p>
        `
    },
    en: {
        gameTitle: "Civilization IX",
        currentPlayer: "Current Turn",
        p1Name: "Player 1",
        p2Name: "Player 2",
        round: "Round",
        deckRemaining: "Deck",
        p1ScoreLabel: "Black Score:",
        p2ScoreLabel: "White Score:",
        aiControl: "AI Control White Player",
        rulesBtn: "Rules",
        restartBtn: "Restart",
        p1HandLabel: "Black Player 1 Hand",
        p2HandLabel: "White Player 2 Hand",
        discardLabel: "Discard",
        modalClose: "Close",
        gameOverTitle: "Game Over!",
        p1Win: "Player 1 (Black) Wins!",
        p2Win: "Player 2 (White) Wins!",
        draw: "It's a Draw!",
        scoreDetail: "Final Score - Black: {s1}, White: {s2}",
        alertPlaced: "You have already placed a piece this turn. Please discard to end your turn.",
        alertSelectCard: "Please select a card first!",
        alertRedOnly: "Cover failed! Only red cards can cover opponent's pieces.",
        alertRedHigher: "Cover failed! Red card value ({v1}) must be higher than the target piece ({v2}).",
        alertRedSupport: "Cover failed! Target cell must be adjacent to your existing piece with same or adjacent value.",
        alertInvalidMove: "Invalid move! Please check:\n1. Match color and value (for 1-3 point cells)\n2. Match color and adjacent to your piece with same or adjacent value\n3. Red card cover needs higher value and your support piece nearby",
        rulesHtml: `
            <h1>ğŸ“œ Civilization IX Manual</h1>
            <p><strong>Civilization IX</strong> is a 2-player abstract strategy game combining space occupation and hand management.</p>
            <div class="rules-story">
                <p>Colors: Yellow-Plains, Green-Forest, Blue-River, Brown-Mountain, Red-War</p>
            </div>
            <hr>
            <h3>1. Components</h3>
            <ul>
                <li><strong>Star Map (Board)</strong>: 10x10 grid with 4 base colors.</li>
                <li><strong>Civilization (Hand)</strong>: 8 sets of yellow cards (1-9), 4 sets of green cards (1-9), 4 sets of blue cards (1-5), 4 sets of brown cards (5-9),  4 sets of red cards (5-9).</li>
            </ul>
            <hr>
            <h3>2. Turn Flow</h3>
            <p>1. Draw 2 cards; 2. Place up to 1 card; 3. Discard until hand â‰¤ 11.</p>
            <hr>
            <h3>3. Placement Rules</h3>
            <ul>
                <li><strong>Initial</strong>: Match card color and cell color, and value.</li>
                <li><strong>Expansion</strong>: Match color. Must be adjacent to your existing piece. Value must be same or adjacent (Â±1).</li>
                <li><strong>Overdrive (Cover)</strong>: <strong>Red cards only</strong>. Can cover opponent's piece if:
                    <ul>
                        <li>Red card value is <strong>higher</strong> than opponent's piece.</li>
                        <li>Must be adjacent to your existing piece with same or adjacent (Â±1) value.</li>
                    </ul>
                </li>
            </ul>
            <hr>
            <h3>4. Scoring</h3>
            <p><strong>Chain Scoring Rule</strong>: Connected pieces form a "Civilization Chain". A piece scores only if the chain contains <strong>all values smaller than it</strong>.</p>
        `
    }
};

// DOM å…ƒç´ 
const boardEl = document.getElementById('board');
const p1HandEl = document.getElementById('p1-hand');
const p2HandEl = document.getElementById('p2-hand');
const turnIndicatorEl = document.getElementById('current-player-name');
const roundIndicatorEl = document.getElementById('round-number');
const restartBtn = document.getElementById('restart-btn');
const discardSquareEl = document.getElementById('discard-square');
const discardContentEl = document.getElementById('discard-content');
const p1Area = document.getElementById('player1-area');
const p2Area = document.getElementById('player2-area');
const p1CountEl = document.getElementById('p1-hand-count');
const p2CountEl = document.getElementById('p2-hand-count');
const p1ScoreEl = document.getElementById('p1-score');
const p2ScoreEl = document.getElementById('p2-score');
const deckCountEl = document.getElementById('deck-count');
const aiToggleEl = document.getElementById('ai-toggle');
const rulesBtn = document.getElementById('rules-btn');
const rulesModal = document.getElementById('rules-modal');
const rulesModalClose = document.getElementById('rules-modal-close');

// è¯­è¨€åˆ‡æ¢å¤„ç†
const langBtns = document.querySelectorAll('.lang-btn');
langBtns.forEach(btn => {
    btn.addEventListener('click', () => {
        const lang = btn.dataset.lang;
        if (state.currentLang === lang) return;
        
        state.currentLang = lang;
        langBtns.forEach(b => b.classList.toggle('active', b.dataset.lang === lang));
        updateLanguageUI();
    });
});

function updateLanguageUI() {
    const t = i18n[state.currentLang];
    
    // æ›´æ–°å·¦ä¾§è¾¹æ 
    document.querySelector('.sidebar-top h1').textContent = t.gameTitle;
    document.querySelector('.stat-item:nth-child(1) .label').textContent = t.currentPlayer;
    document.querySelector('.stat-item:nth-child(2) .label').textContent = t.round;
    document.querySelector('.stat-item:nth-child(3) .label').textContent = t.deckRemaining;
    
    document.querySelector('.score-card.p1 .player-label').textContent = t.p1ScoreLabel;
    document.querySelector('.score-card.p2 .player-label').textContent = t.p2ScoreLabel;
    
    document.querySelector('.ai-control label').lastChild.textContent = t.aiControl;
    rulesBtn.textContent = t.rulesBtn;
    restartBtn.textContent = t.restartBtn;
    
    // æ›´æ–°æ‰‹ç‰ŒåŒºåŸŸæ ‡ç­¾
    document.querySelector('#player1-area .hand-label').textContent = t.p1HandLabel;
    document.querySelector('#player2-area .hand-label').textContent = t.p2HandLabel;
    
    // æ›´æ–°ä¸¢å¼ƒåŒºæ ‡ç­¾
    document.querySelector('.discard-label').textContent = t.discardLabel;
    
    // æ›´æ–°è§„åˆ™è¯´æ˜æ¨¡æ€æ¡†
    document.querySelector('.rules-scroll-area').innerHTML = t.rulesHtml;
    
    // æ›´æ–°å³ä¾§è§„åˆ™æ 
    const rulesSidebar = document.querySelector('.rules-sidebar');
    if (state.currentLang === 'en') {
        rulesSidebar.innerHTML = `
            <div class="game-rules">
                <section class="rules-section">
                    <h3>Turn Flow</h3>
                    <ol>
                        <li>Draw 2 cards </li>
                        <li>Place 1 card (optional)</li>
                        <li>Discard until hand â‰¤ 11</li>
                    </ol>
                </section>
                <section class="rules-section">
                    <h3>ending conditions</h3>
                    <ul>
                        <li>The game ends when both sides have zero hands.</li>
                        <li>the player with the highest score wins.</li>
                    </ul>
                </section>                
                <section class="rules-section">
                    <h3>Placement</h3>
                    <ul>
                        <li><strong>Initial</strong>: Match color & value.</li>
                        <li><strong>Expansion</strong>: Adjacent, value same or Â±1, match color.</li>
                        <li><strong>Overdrive</strong>: Red only. Value > opponent, and must be adjacent to your existing piece with same or adjacent (Â±1) value.</li>
                    </ul>
                </section>
                <section class="rules-section">
                    <h3>Scoring</h3>
                    <ul>
                        <li>Sum of valid piece values.</li>
                        <li><strong>Valid</strong>: A piece scores only if the chain ( Connected pieces form a "Chain") contains all values smaller than it.</li>
                    </ul>
                </section>
            </div>
        `;
    } else {
        // æ¢å¤ä¸­æ–‡è§„åˆ™æ ï¼ˆç®€åŒ–é€»è¾‘ï¼Œç›´æ¥æ›¿æ¢ HTMLï¼‰
        rulesSidebar.innerHTML = `
            <div class="game-rules">
                <section class="rules-section">
                    <h3>å›åˆæµç¨‹</h3>
                    <ol>
                        <li>æŠ“2å¼ ç‰Œ</li>
                        <li>æ”¾ç½®1å¼ ç‰Œåˆ°æ£‹ç›˜ï¼ˆç¬¦åˆè§„åˆ™ï¼‰</li>
                        <li>ä¸¢å¼ƒ1å¼ ç‰Œï¼ˆå¦‚æ— ç‰Œæ”¾ç½®ï¼Œåˆ™ä¸¢å¼ƒ2å¼ ï¼‰</li>
                    </ol>
                </section>
                <section class="rules-section">
                    <h3>è½å­è§„åˆ™</h3>
                    <ul>
                        <li><strong>åˆå§‹å é¢†</strong>ï¼šæ‰‹ç‰Œä¸æ ¼å­é¢œè‰²ä¸æ•°å€¼å‡ç›¸åŒã€‚</li>
                        <li><strong>æ‰©å¼ è¿é€š</strong>ï¼šæ”¾ç½®åœ¨å·±æ–¹å››å‘¨ï¼Œä¸å·±æ–¹æ£‹å­æ•°å€¼ç›¸åŒæˆ–ç›¸é‚»(Â±1)ï¼Œä¸æ ¼å­é¢œè‰²ç›¸åŒã€‚</li>
                        <li><strong>é™ç»´è¦†ç›–</strong>ï¼š<strong>ä»…é™çº¢è‰²æ‰‹ç‰Œ</strong>ã€‚æ•°å€¼éœ€å¤§äºå¯¹æ‰‹ä¸”å››å‘¨æœ‰å·±æ–¹æ£‹å­(æ•°å€¼ç›¸åŒæˆ–ç›¸é‚»)å¯å°†å¯¹æ‰‹ç‰Œè¦†ç›–ã€‚</li>
                    </ul>
                </section>
                <section class="rules-section">
                    <h3>ç»“æŸæ¡ä»¶</h3>
                    <ul>
                        <li>ç‰Œå †è€—å°½ï¼ŒåŒæ–¹æ‰‹ç‰Œä¸º0</li>
                        <li>å¾—åˆ†é«˜è€…è·èƒœ</li>
                    </ul>
                </section>                
                <section class="rules-section">
                    <h3>å¾—åˆ†ç®—æ³•</h3>
                    <ul>
                        <li>å¾—åˆ†ä¸ºæ‰€æœ‰æœ‰æ•ˆæ£‹å­æ•°å€¼ä¹‹å’Œã€‚</li>
                        <li><strong>æœ‰æ•ˆæ ¡éªŒ</strong>ï¼šè¯¥æ£‹å­è¿æ¥çš„å·±æ–¹æ£‹å­ä¸­åŒ…å«æ‰€æœ‰æ¯”è¯¥æ£‹å­æ•°å€¼å°çš„<strong>æ‰€æœ‰</strong>æ•°å€¼ï¼ˆå¦‚4åˆ†éœ€æœ‰1,2,3ï¼‰ã€‚</li>
                    </ul>
                </section>
            </div>
        `;
    }

    // é‡æ–°æ¸²æŸ“å½“å‰çŠ¶æ€æ–‡æœ¬
    updateUI();
}



// ç›‘å¬AIå¼€å…³
aiToggleEl.addEventListener('change', (e) => {
    state.isAIEnabled = e.target.checked;
    renderHands(); // ç«‹å³æ›´æ–°æ‰‹ç‰Œæ˜¾ç¤ºï¼ˆéšè—æˆ–æ˜¾ç¤ºï¼‰
    
    // å¦‚æœè½®åˆ°ç©å®¶2ä¸”åˆšåˆšå¼€å¯äº†AIï¼Œç«‹å³æ‰§è¡Œ
    if (state.currentPlayer === 2 && state.isAIEnabled && state.gameActive) {
        runAIAction();
    }
});

// æ¸¸æˆè¯´æ˜å¼¹çª—é€»è¾‘
rulesBtn.addEventListener('click', () => {
    rulesModal.classList.remove('hidden');
});

rulesModalClose.addEventListener('click', () => {
    rulesModal.classList.add('hidden');
});

// ç‚¹å‡»æ¨¡æ€æ¡†èƒŒæ™¯å…³é—­
rulesModal.addEventListener('click', (e) => {
    if (e.target === rulesModal) {
        rulesModal.classList.add('hidden');
    }
});

// è¾…åŠ©å‡½æ•°ï¼šç”Ÿæˆéšæœºæ•´æ•° [min, max]
function getRandomInt(min, max) {
    return Math.floor(Math.random() * (max - min + 1)) + min;
}

// åˆå§‹åŒ–ç‰Œå †
function initDeck() {
    const deck = [];
    const config = [
        { color: 'yellow', groups: 8 , minv: 1, maxv: 9},      
        { color: 'green', groups: 4 ,minv: 1, maxv: 9},       
        { color: 'blue', groups: 4 ,minv: 1, maxv: 5},
        { color: 'brown', groups: 4 , minv: 4,maxv: 9},        
        { color: 'red', groups: 2 , minv: 5, maxv: 9},
    ];

    config.forEach(item => {
        for (let g = 0; g < item.groups; g++) {
            for (let v = item.minv; v <= item.maxv; v++) {
                deck.push({ color: item.color, value: v });
            }
        }
    });

    // æ´—ç‰Œ (Fisher-Yates)
    for (let i = deck.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [deck[i], deck[j]] = [deck[j], deck[i]];
    }
    
    return deck;
}

// åˆå§‹åŒ–æ¸¸æˆ
function initGame() {
    // åˆå§‹åŒ–ç‰Œå †
    state.deck = initDeck();

    // åˆå§‹åŒ–æ£‹ç›˜
    state.board = Array(BOARD_SIZE).fill(null).map(() => 
        Array(BOARD_SIZE).fill(null).map(() => ({
            owner: null,
            color: CELL_COLORS[Math.floor(Math.random() * CELL_COLORS.length)],
            value: 0, // é»˜è®¤ä¸º0
            pieceColor: null,
            pieceValue: null
        }))
    );

    // éšæœºé€‰æ‹©20ä¸ªæ ¼å­è®¾ä¸º1-3ï¼Œä¸”é¢œè‰²å›ºå®š
    const colorForValue1 = ['yellow', 'blue', 'green'];
    let count = 0;
    while (count < 20) {
        const r = Math.floor(Math.random() * BOARD_SIZE);
        const c = Math.floor(Math.random() * BOARD_SIZE);
        if (state.board[r][c].value === 0) {
            state.board[r][c].value = getRandomInt(1, 3);
            state.board[r][c].color = colorForValue1[count % 3] || 'yellow';
            count++;
        }
    }

    // åˆå§‹åŒ–æ‰‹ç‰Œï¼šä»ç‰Œå †ä¸­æŠ½å– INITIAL_HAND_SIZE å¼ ç‰Œ
    state.players[1].hand = [];
    state.players[2].hand = [];
    
    for (let i = 0; i < INITIAL_HAND_SIZE; i++) {
        drawCard(1);
        drawCard(2);
    }
    // å…ˆæ‰‹ç©å®¶ï¼ˆç©å®¶ 1ï¼‰å¤šæŠ“ä¸€å¼ ç‰Œ,æš‚æ—¶å–æ¶ˆ
    drawCard(1);
    drawCard(1);    

    state.currentPlayer = 1;
    state.round = 1;
    state.selectedCardIndex = null;
    state.discardedCard = null;
    state.lastMove = null;
    state.placedThisTurn = false;
    state.gameActive = true;

    // æ¸²æŸ“
    renderBoard();
    renderHands();
    renderDiscardSquare();
    updateUI();
}

// è¾…åŠ©å‡½æ•°ï¼šç”Ÿæˆä¸€å¼ éšæœºå¡ç‰Œ
function generateRandomCard() {
    return {
        color: CARD_COLORS[Math.floor(Math.random() * CARD_COLORS.length)],
        value: getRandomInt(1, 9) // æ•°å€¼èŒƒå›´æ”¹ä¸º 1-9
    };
}

// æ¸²æŸ“æ£‹ç›˜
function renderBoard() {
    boardEl.innerHTML = '';
    const selectedCard = state.selectedCardIndex !== null ? state.players[state.currentPlayer].hand[state.selectedCardIndex] : null;

    for (let r = 0; r < BOARD_SIZE; r++) {
        for (let c = 0; c < BOARD_SIZE; c++) {
            const cellData = state.board[r][c];
            const cell = document.createElement('div');
            
            // æ·»åŠ åŸºç¡€ç±»å’Œé¢œè‰²ç±»
            cell.className = `cell ${cellData.color}`;
            cell.dataset.row = r;
            cell.dataset.col = c;

            // æ£€æŸ¥å¹¶æ·»åŠ æœ€åè½å­çš„é«˜äº®æç¤º
            if (state.lastMove && state.lastMove.row === r && state.lastMove.col === c) {
                cell.classList.add('last-move');
            }

            // æ£€æŸ¥å¹¶æ·»åŠ åˆæ³•è½å­ä½ç½®çš„é«˜äº®æç¤º
            if (selectedCard && isValidMove(r, c, selectedCard)) {
                cell.classList.add('highlight-valid');
            }
            
            // æ˜¾ç¤ºæ•°å€¼
            // åˆ›å»ºä¸€ä¸ª span æ¥æ˜¾ç¤ºæ•°å­—ï¼Œç¡®ä¿å®ƒåœ¨åº•å±‚
            const numberSpan = document.createElement('span');
            numberSpan.className = 'cell-number';
            // åªæœ‰æ•°å€¼ä¸º0æ—¶æ‰ä¸æ˜¾ç¤º
            numberSpan.textContent = cellData.value === 0 ? '' : cellData.value.toString();
            cell.appendChild(numberSpan);
            
            // å§‹ç»ˆæ·»åŠ ç‚¹å‡»äº‹ä»¶ï¼Œä»¥ä¾¿å¤„ç†è¦†ç›–é€»è¾‘
            cell.addEventListener('click', () => handleCellClick(r, c));
            
            // æ”¾ç½®æ£‹å­
            if (cellData.owner) {
                const piece = document.createElement('div');
                piece.className = `piece p${cellData.owner} ${cellData.pieceColor}`;
                // æ˜¾ç¤ºæ£‹å­çš„æ•°å€¼
                piece.textContent = cellData.pieceValue;
                
                cell.appendChild(piece);
                cell.classList.add('has-piece');
            }
            
            boardEl.appendChild(cell);
        }
    }
}

// æŠ½å–è½å­åˆæ³•æ€§æ ¡éªŒé€»è¾‘ (æ”¯æŒä¼ å…¥è‡ªå®šä¹‰æ£‹ç›˜å’Œç©å®¶ï¼Œç”¨äº AI æ¨¡æ‹Ÿ)
function isValidMove(row, col, card, board = state.board, playerId = state.currentPlayer) {
    const cell = board[row][col];
    const opponent = playerId === 1 ? 2 : 1;
    
    // è¦†ç›–å¯¹æ‰‹æ£‹å­çš„è§„åˆ™ï¼šä»…é™çº¢è‰²æ‰‹ç‰Œï¼Œä¸”æ•°å€¼å¿…é¡»é«˜äºå¯¹æ–¹
    if (cell.owner === opponent) {
        // å¿…é¡»æ˜¯çº¢è‰²æ‰‹ç‰Œ
        if (card.color !== 'red') return false;
        
        // å¿…é¡»æ•°å€¼é«˜äºå¯¹æ–¹
        if (card.value <= cell.pieceValue) return false;
        
        // ä¸”è¦æ±‚ç›®æ ‡æ ¼å››å‘¨æœ‰å·±æ–¹æ•°å€¼ç›¸åŒæˆ–ç›¸é‚»çš„æ£‹å­
        const directions = [[-1, 0], [1, 0], [0, -1], [0, 1]];
        for (const [dr, dc] of directions) {
            const nr = row + dr;
            const nc = col + dc;
            if (nr >= 0 && nr < BOARD_SIZE && nc >= 0 && nc < BOARD_SIZE) {
                const neighbor = board[nr][nc];
                if (neighbor.owner === playerId) {
                    if (Math.abs(neighbor.pieceValue - card.value) <= 1) {
                        return true;
                    }
                }
            }
        }
        return false;
    } 
    
    // æ™®é€šè½å­æ£€æŸ¥ï¼šè¯¥ä½ç½®æ˜¯å¦å·²æœ‰æ£‹å­
    if (cell.owner !== null) return false;

    // è§„åˆ™ä¸€ï¼šæ‰‹ç‰Œæ”¾ç½®åœ¨æ£‹ç›˜ä¸Šé¢œè‰²ç›¸åŒçš„æ ¼å­ï¼Œä¸”æ‰‹ç‰Œå’Œæ ¼å­æ•°å€¼ç›¸åŒ
    if (card.color === cell.color && card.value === cell.value) {
        return true;
    } 

    // è§„åˆ™äºŒï¼šæ‰‹ç‰Œæ”¾ç½®åœ¨å’Œæ£‹ç›˜é¢œè‰²ç›¸åŒçš„æ ¼å­ï¼Œä¸”æ ¼å­æ•°å€¼ä¸º0ï¼Œä¸”æ ¼å­ç›¸é‚»çš„æ ¼å­å­˜åœ¨å·±æ–¹æ‰‹ç‰Œï¼Œä¸”å·±æ–¹æ‰‹ç‰Œçš„æ•°å€¼å’Œæ”¾ç½®çš„æ‰‹ç‰Œæ•°å€¼ç›¸é‚»
    if (card.color === cell.color) {
        const directions = [[-1, 0], [1, 0], [0, -1], [0, 1]];
        for (const [dr, dc] of directions) {
            const nr = row + dr;
            const nc = col + dc;
            if (nr >= 0 && nr < BOARD_SIZE && nc >= 0 && nc < BOARD_SIZE) {
                const neighbor = board[nr][nc];
                if (neighbor.owner === playerId) {
                    // æ”¯æŒç›¸é‚»æ•°å€¼æˆ–ç›¸åŒæ•°å€¼
                    if (Math.abs(neighbor.pieceValue - card.value) <= 1) {
                        return true;
                    }
                }
            }
        }
    }

    return false;
}

// æ¸²æŸ“æ‰‹ç‰Œ
function renderHands() {
    renderHand(1, p1HandEl);
    renderHand(2, p2HandEl);
    
    // æ›´æ–°æ‰‹ç‰Œè®¡æ•°
    p1CountEl.textContent = state.players[1].hand.length;
    p2CountEl.textContent = state.players[2].hand.length;
}

function renderHand(playerId, container) {
    container.innerHTML = '';
    const hand = state.players[playerId].hand;
    
    // å¦‚æœæ˜¯ç©å®¶2ä¸”å¼€å¯äº†AIæ‰˜ç®¡ï¼Œä¸æ˜¾ç¤ºç‰Œé¢
    const shouldHideHand = playerId === 2 && state.isAIEnabled;
    
    hand.forEach((card, index) => {
        const cardEl = document.createElement('div');
        
        if (shouldHideHand) {
            // AIæ‰˜ç®¡æ—¶æ˜¾ç¤ºèƒŒé¢æ ·å¼
            cardEl.className = `card ai-hidden`;
            cardEl.textContent = '?';
            container.appendChild(cardEl);
            return;
        }

        // æ‰‹ç‰Œç°åœ¨æœ‰é¢œè‰²å±æ€§
        cardEl.className = `card ${card.color}`;
        
        // æ˜¾ç¤ºæ•°å­—
        cardEl.textContent = card.value;
        
        // åªæœ‰å½“å‰ç©å®¶å¯ä»¥ç‚¹å‡»è‡ªå·±çš„æ‰‹ç‰Œ
        if (playerId === state.currentPlayer && state.gameActive) {
            cardEl.addEventListener('click', () => selectCard(index));
            if (state.selectedCardIndex === index) {
                cardEl.classList.add('selected');
            }
        } else {
            // éå½“å‰å›åˆç©å®¶çš„æ‰‹ç‰Œï¼Œæˆ–è€…ä¸æ˜¯è‡ªå·±çš„æ‰‹ç‰Œ
            // å¯¹æ–¹çš„æ‰‹ç‰Œï¼Œå¦‚æœæ˜¯æœ¬åœ°åŒäººæ¸¸æˆï¼Œæ˜ç‰Œæ˜¾ç¤ºä¹Ÿå¯ä»¥
            // è¿™é‡Œæˆ‘ä»¬ä¿æŒåŸæ ·ï¼Œæˆ–è€…å¯ä»¥è€ƒè™‘æ˜¯å¦éšè—å¯¹æ–¹æ‰‹ç‰Œå†…å®¹ï¼Ÿ
            // æ—¢ç„¶æ˜¯åŒå±æ¡Œæ¸¸ï¼Œé€šå¸¸æ˜¯æ˜ç‰Œæˆ–è€…ç‚¹å‡»æŸ¥çœ‹ï¼Œè¿™é‡Œç®€å•èµ·è§æ˜ç‰Œæ˜¾ç¤º
            if (playerId !== state.currentPlayer) {
                cardEl.style.opacity = '0.7';
                cardEl.style.cursor = 'default';
            }
        }
        
        container.appendChild(cardEl);
    });
}

// æ›´æ–° UI çŠ¶æ€
function updateUI() {
    const t = i18n[state.currentLang];
    turnIndicatorEl.textContent = state.currentPlayer === 1 ? t.p1Name : t.p2Name;
    turnIndicatorEl.className = 'value ' + (state.currentPlayer === 1 ? 'p1' : 'p2');
    roundIndicatorEl.textContent = state.round;
    deckCountEl.textContent = state.deck.length;

    if (state.currentPlayer === 1) {
        p1Area.classList.add('active');
        p2Area.classList.remove('active');
    } else {
        p1Area.classList.remove('active');
        p2Area.classList.add('active');
    }

    const scores = calculateScores();
    p1ScoreEl.textContent = scores[1];
    p2ScoreEl.textContent = scores[2];

    checkGameOver(scores);
}

// æ£€æŸ¥æ¸¸æˆæ˜¯å¦ç»“æŸ
function checkGameOver(scores) {
    if (!state.gameActive) return;
    if (state.players[1].hand.length === 0 && state.players[2].hand.length === 0) {
        state.gameActive = false;
        const t = i18n[state.currentLang];
        
        let resultMsg = "";
        if (scores[1] > scores[2]) {
            resultMsg = t.p1Win;
        } else if (scores[2] > scores[1]) {
            resultMsg = t.p2Win;
        } else {
            resultMsg = t.draw;
        }
        
        const detailMsg = t.scoreDetail.replace('{s1}', scores[1]).replace('{s2}', scores[2]);
        showModal(`<h2>${t.gameOverTitle}</h2><p>${resultMsg}</p><p>${detailMsg}</p>`);
    }
}

// å¼¹çª—æç¤º
const messageModal = document.getElementById('message-modal');
const modalText = document.getElementById('modal-text');
const modalCloseBtn = document.getElementById('modal-close-btn');

function showModal(content) {
    const t = i18n[state.currentLang];
    modalText.innerHTML = content;
    modalCloseBtn.textContent = t.modalClose;
    messageModal.classList.remove('hidden');
}

modalCloseBtn.addEventListener('click', () => {
    messageModal.classList.add('hidden');
});

// è®¡ç®—åŒæ–¹åˆ†æ•°çš„é€»è¾‘ (æ”¯æŒä¼ å…¥è‡ªå®šä¹‰æ£‹ç›˜ç”¨äº AI è¯„ä¼°)
function calculateScores(customBoard = null) {
    const boardToUse = customBoard || state.board;
    const scores = { 1: 0, 2: 0 };
    const visited = Array(BOARD_SIZE).fill(null).map(() => Array(BOARD_SIZE).fill(false));

    for (let r = 0; r < BOARD_SIZE; r++) {
        for (let c = 0; c < BOARD_SIZE; c++) {
            const cell = boardToUse[r][c];
            if (cell.owner && !visited[r][c]) {
                const component = [];
                const valueSet = new Set();
                const owner = cell.owner;
                
                // BFS æŸ¥æ‰¾æ•´ä¸ªè¿é€šå—
                const queue = [[r, c]];
                visited[r][c] = true;
                
                while (queue.length > 0) {
                    const [currR, currC] = queue.shift();
                    const currCell = boardToUse[currR][currC];
                    component.push(currCell);
                    valueSet.add(currCell.pieceValue);
                    
                    const directions = [[-1, 0], [1, 0], [0, -1], [0, 1]];
                    for (const [dr, dc] of directions) {
                        const nr = currR + dr;
                        const nc = currC + dc;
                        if (nr >= 0 && nr < BOARD_SIZE && nc >= 0 && nc < BOARD_SIZE) {
                            const neighbor = boardToUse[nr][nc];
                            if (neighbor.owner === owner && !visited[nr][nc]) {
                                visited[nr][nc] = true;
                                queue.push([nr, nc]);
                            }
                        }
                    }
                }
                
                // ä¼˜åŒ–å¾—åˆ†è®¡ç®—ï¼šå…ˆæ‰¾åˆ°æœ€å¤§è¿ç»­å€¼ X
                let maxContinuousValue = 0;
                while (valueSet.has(maxContinuousValue + 1)) {
                    maxContinuousValue++;
                }
                
                // è¿é€šå—å¾—åˆ†æ³•åˆ™ï¼šæ•°å€¼ä¸º v çš„æ£‹å­å¾—åˆ†ï¼Œå‰ææ˜¯å—å†…åŒ…å« 1 åˆ° v-1
                // ä¹Ÿå°±æ˜¯è¯´ pieceValue <= maxContinuousValue + 1 çš„æ£‹å­éƒ½èƒ½å¾—åˆ†
                for (const piece of component) {
                    if (piece.pieceValue <= maxContinuousValue + 1) {
                        scores[owner] += piece.pieceValue;
                    }
                }
            }
        }
    }
    return scores;
}

// æ¸²æŸ“ä¸¢å¼ƒåŒº
function renderDiscardSquare() {
    discardContentEl.innerHTML = '';
    if (state.discardedCard) {
        const cardEl = document.createElement('div');
        cardEl.className = `card ${state.discardedCard.color}`;
        cardEl.textContent = state.discardedCard.value;
        discardContentEl.appendChild(cardEl);
    }
}

// ä¸¢å¼ƒé€»è¾‘
discardSquareEl.addEventListener('click', () => {
    if (!state.gameActive) return;
    if (state.selectedCardIndex === null) {
        alert("è¯·å…ˆé€‰æ‹©ä¸€å¼ è¦ä¸¢å¼ƒçš„æ‰‹ç‰Œï¼");
        return;
    }

    const card = state.players[state.currentPlayer].hand[state.selectedCardIndex];
    
    // 1. æ›´æ–°ä¸¢å¼ƒåŒº
    state.discardedCard = { ...card };
    
    // 2. ç§»é™¤æ‰‹ç‰Œ
    state.players[state.currentPlayer].hand.splice(state.selectedCardIndex, 1);
    state.selectedCardIndex = null;
    
    // 3. æ¸²æŸ“
    renderHands();
    renderDiscardSquare();

    // 3. æ£€æŸ¥å›åˆç»“æŸæ¡ä»¶ï¼šæ‰‹ç‰Œæ•°ä¸å¤§äº åˆå§‹æ‰‹ç‰Œæ•°
    if (state.players[state.currentPlayer].hand.length <= INITIAL_HAND_SIZE) {
        endTurn();
    } else {
        updateUI(); // å®æ—¶æ›´æ–°åˆ†æ•°å’ŒUI
        // alert(`å·²ä¸¢å¼ƒã€‚å½“å‰æ‰‹ç‰Œæ•°: ${state.players[state.currentPlayer].hand.length}ï¼Œè¿˜éœ€ä¸¢å¼ƒæˆ–æ”¾ç½®ç›´åˆ°æ‰‹ç‰Œæ•° <= 12 ä»¥ç»“æŸå›åˆã€‚`);
    }
});

// äº¤äº’é€»è¾‘ï¼šé€‰æ‹©æ‰‹ç‰Œ
function selectCard(index) {
    if (!state.gameActive) return;
    
    // å¦‚æœç‚¹å‡»å·²é€‰ä¸­çš„ï¼Œå–æ¶ˆé€‰ä¸­
    if (state.selectedCardIndex === index) {
        state.selectedCardIndex = null;
    } else {
        state.selectedCardIndex = index;
    }
    renderHands(); // é‡æ–°æ¸²æŸ“ä»¥æ›´æ–°é€‰ä¸­æ ·å¼
    renderBoard(); // é‡æ–°æ¸²æŸ“æ£‹ç›˜ä»¥æ˜¾ç¤º/éšè—é«˜äº®
}

// äº¤äº’é€»è¾‘ï¼šç‚¹å‡»æ£‹ç›˜
function handleCellClick(row, col) {
    if (!state.gameActive) return;
    const t = i18n[state.currentLang];
    
    if (state.placedThisTurn) {
        alert(t.alertPlaced);
        return;
    }
    if (state.selectedCardIndex === null) {
        alert(t.alertSelectCard);
        return;
    }
    
    const card = state.players[state.currentPlayer].hand[state.selectedCardIndex];
    
    if (!isValidMove(row, col, card)) {
        const cell = state.board[row][col];
        const opponent = state.currentPlayer === 1 ? 2 : 1;
        
        if (cell.owner === opponent) {
            if (card.color !== 'red') {
                alert(t.alertRedOnly);
            } else if (card.value <= cell.pieceValue) {
                alert(t.alertRedHigher.replace('{v1}', card.value).replace('{v2}', cell.pieceValue));
            } else {
                alert(t.alertRedSupport);
            }
        } else {
            alert(t.alertInvalidMove);
        }
        return;
    }
    
    // æ”¾ç½®æ£‹å­
    placePiece(row, col);
}

// æ”¾ç½®æ£‹å­é€»è¾‘
function placePiece(row, col) {
    const card = state.players[state.currentPlayer].hand[state.selectedCardIndex];

    // 1. æ›´æ–°æ£‹ç›˜
    state.board[row][col].owner = state.currentPlayer;
    state.board[row][col].pieceValue = card.value; // è®°å½•æ”¾ç½®çš„æ•°å€¼
    state.board[row][col].pieceColor = card.color; // è®°å½•æ”¾ç½®çš„é¢œè‰²
    
    // 1.5 æ›´æ–°æœ€åè½å­ä½ç½®
    state.lastMove = { row, col };
    
    // 2. ç§»é™¤æ‰‹ç‰Œ
    state.players[state.currentPlayer].hand.splice(state.selectedCardIndex, 1);
    state.selectedCardIndex = null;
    state.placedThisTurn = true; // æ ‡è®°å·²æ”¾ç½®
    
    // 3. æ¸²æŸ“æ›´æ–°
    renderBoard();
    renderHands();

    // 3. æ£€æŸ¥å›åˆç»“æŸæ¡ä»¶ï¼šæ‰‹ç‰Œæ•°ä¸å¤§äº æ‰‹ç‰Œæ•°
    if (state.players[state.currentPlayer].hand.length <= INITIAL_HAND_SIZE) {
        endTurn();
    } else {
        updateUI(); // å®æ—¶æ›´æ–°åˆ†æ•°å’ŒUI
    }
}

// --- AI ç­–ç•¥ç›¸å…³å‡½æ•° ---

// è¯„ä¼°å‡½æ•°ï¼šè®¡ç®—å½“å‰æ£‹ç›˜å¯¹ç‰¹å®šç©å®¶çš„ä»·å€¼
function evaluateBoard(tempBoard, playerId) {
    const scores = calculateScores(tempBoard);
    let whitePieceCount = 0;
    for (let r = 0; r < BOARD_SIZE; r++) {
        for (let c = 0; c < BOARD_SIZE; c++) {
            if (tempBoard[r][c].owner === 2) whitePieceCount++;
        }
    }
    return (scores[2] - scores[1]) + whitePieceCount;
}

// å¯¹æŠ—æ€§æœç´¢ç®—æ³•ï¼šMinimax + Alpha-Beta å‰ªæ + å¯å‘å¼å®½åº¦é™åˆ¶
function minimax(board, p1Hand, p2Hand, depth, alpha, beta, isMaximizing) {
    // é€’å½’ç»ˆç‚¹ï¼šè¾¾åˆ°æ·±åº¦æˆ–åŒæ–¹æ‰‹ç‰Œè€—å°½
    if (depth === 0 || (p1Hand.length === 0 && p2Hand.length === 0)) {
        return evaluateBoard(board, 2);
    }

    const currentPlayer = isMaximizing ? 2 : 1;
    const currentHand = isMaximizing ? p2Hand : p1Hand;

    // æ”¶é›†æ‰€æœ‰åˆæ³•è½å­å¹¶è¿›è¡Œåˆæ­¥è¯„ä¼°
    const possibleMoves = [];
    for (let i = 0; i < currentHand.length; i++) {
        const card = currentHand[i];
        for (let r = 0; r < BOARD_SIZE; r++) {
            for (let c = 0; c < BOARD_SIZE; c++) {
                if (isValidMove(r, c, card, board, currentPlayer)) {
                    // ç®€å•çš„å³æ—¶è¯„ä¼°
                    const cell = board[r][c];
                    const prevOwner = cell.owner;
                    const prevPieceValue = cell.pieceValue;
                    const prevPieceColor = cell.pieceColor;

                    cell.owner = currentPlayer;
                    cell.pieceValue = card.value;
                    cell.pieceColor = card.color;
                    
                    const immediateEval = evaluateBoard(board, 2);
                    possibleMoves.push({ r, c, handIndex: i, eval: immediateEval });

                    // å›æº¯
                    cell.owner = prevOwner;
                    cell.pieceValue = prevPieceValue;
                    cell.pieceColor = prevPieceColor;
                }
            }
        }
    }

    // å¦‚æœæ²¡æœ‰ä»»ä½•åˆæ³•è½å­ï¼Œè§†ä¸ºè·³è¿‡æœ¬è½®ï¼Œç»§ç»­æ¨¡æ‹Ÿä¸‹ä¸€å±‚
    if (possibleMoves.length === 0) {
        return minimax(board, p1Hand, p2Hand, depth - 1, alpha, beta, !isMaximizing);
    }

    // å¯å‘å¼å‰ªæï¼šé™åˆ¶æœç´¢å®½åº¦
    const searchWidth = depth > 2 ? 3 : 5;
    if (isMaximizing) {
        possibleMoves.sort((a, b) => b.eval - a.eval);
        let maxEval = -Infinity;
        for (const move of possibleMoves.slice(0, searchWidth)) {
            const card = currentHand[move.handIndex];
            const cell = board[move.r][move.c];
            const prevOwner = cell.owner;
            const prevPieceValue = cell.pieceValue;
            const prevPieceColor = cell.pieceColor;

            cell.owner = 2;
            cell.pieceValue = card.value;
            cell.pieceColor = card.color;

            const nextP2Hand = [...p2Hand];
            nextP2Hand.splice(move.handIndex, 1);

            const evaluation = minimax(board, p1Hand, nextP2Hand, depth - 1, alpha, beta, false);
            maxEval = Math.max(maxEval, evaluation);
            alpha = Math.max(alpha, evaluation);

            cell.owner = prevOwner;
            cell.pieceValue = prevPieceValue;
            cell.pieceColor = prevPieceColor;

            if (beta <= alpha) break; // Beta å‰ªæ
        }
        return maxEval;
    } else {
        possibleMoves.sort((a, b) => a.eval - b.eval); // å¯¹æ‰‹ä¼šé€‰å¯¹ AI æœ€ä¸åˆ©çš„
        let minEval = Infinity;
        for (const move of possibleMoves.slice(0, searchWidth)) {
            const card = currentHand[move.handIndex];
            const cell = board[move.r][move.c];
            const prevOwner = cell.owner;
            const prevPieceValue = cell.pieceValue;
            const prevPieceColor = cell.pieceColor;

            cell.owner = 1;
            cell.pieceValue = card.value;
            cell.pieceColor = card.color;

            const nextP1Hand = [...p1Hand];
            nextP1Hand.splice(move.handIndex, 1);

            const evaluation = minimax(board, nextP1Hand, p2Hand, depth - 1, alpha, beta, true);
            minEval = Math.min(minEval, evaluation);
            beta = Math.min(beta, evaluation);

            cell.owner = prevOwner;
            cell.pieceValue = prevPieceValue;
            cell.pieceColor = prevPieceColor;

            if (beta <= alpha) break; // Alpha å‰ªæ
        }
        return minEval;
    }
}

// AI å†³ç­–å…¥å£
async function runAIAction() {
    if (!state.isAIEnabled || state.currentPlayer !== 2 || !state.gameActive) return;

    console.log("AI å¼€å§‹æ·±åº¦æ€è€ƒ (Minimax å¯¹æŠ—æœç´¢)...");
    
    let bestMove = null;
    let maxEval = -Infinity;
    
    const p1Hand = state.players[1].hand;
    const p2Hand = state.players[2].hand;
    const tempBoard = state.board.map(row => row.map(cell => ({ ...cell })));

    // 1. æ”¶é›†å¹¶åˆæ­¥è¯„ä¼°æ‰€æœ‰åˆæ³•è½å­
    const initialMoves = [];
    for (let i = 0; i < p2Hand.length; i++) {
        const card = p2Hand[i];
        for (let r = 0; r < BOARD_SIZE; r++) {
            for (let c = 0; c < BOARD_SIZE; c++) {
                if (isValidMove(r, c, card, tempBoard, 2)) {
                    const cell = tempBoard[r][c];
                    const prevOwner = cell.owner;
                    const prevPieceValue = cell.pieceValue;
                    const prevPieceColor = cell.pieceColor;

                    cell.owner = 2;
                    cell.pieceValue = card.value;
                    cell.pieceColor = card.color;
                    
                    const immediateEval = evaluateBoard(tempBoard, 2);
                    initialMoves.push({ r, c, handIndex: i, eval: immediateEval });

                    cell.owner = prevOwner;
                    cell.pieceValue = prevPieceValue;
                    cell.pieceColor = prevPieceColor;
                }
            }
        }
    }

    if (initialMoves.length === 0) {
        console.log("AI æ— æ³•è½å­ï¼Œå‡†å¤‡å¼ƒç‰Œ");
        setTimeout(() => aiDiscard(), 600);
        return;
    }

    // 2. å¯å‘å¼å‰ªæ + Minimax
    initialMoves.sort((a, b) => b.eval - a.eval);
    const movesToExplore = initialMoves.slice(0, 10);

    for (const move of movesToExplore) {
        const card = p2Hand[move.handIndex];
        const cell = tempBoard[move.r][move.c];
        
        const prevOwner = cell.owner;
        const prevPieceValue = cell.pieceValue;
        const prevPieceColor = cell.pieceColor;

        cell.owner = 2;
        cell.pieceValue = card.value;
        cell.pieceColor = card.color;

        const remainingP2Hand = [...p2Hand];
        remainingP2Hand.splice(move.handIndex, 1);

        // æ·±åº¦è®¾ä¸º 8ï¼Œè¡¨ç¤ºæ¨¡æ‹Ÿåç»­ 8 ä¸ªå›åˆï¼ˆAI->å¯¹æ‰‹->AI->å¯¹æ‰‹ï¼‰
        const evaluation = minimax(tempBoard, p1Hand, remainingP2Hand, 8, -Infinity, Infinity, false);
        
        if (evaluation > maxEval) {
            maxEval = evaluation;
            bestMove = move;
        }

        cell.owner = prevOwner;
        cell.pieceValue = prevPieceValue;
        cell.pieceColor = prevPieceColor;
    }

    if (bestMove) {
        console.log(`AI é€‰å®šæœ€ä½³è½å­: ç´¢å¼• ${bestMove.handIndex}, ä½ç½® (${bestMove.r}, ${bestMove.c}), é¢„æœŸè¯„åˆ†: ${maxEval}`);
        
        await new Promise(resolve => setTimeout(resolve, 600));
        state.selectedCardIndex = bestMove.handIndex;
        placePiece(bestMove.r, bestMove.c);
        
        setTimeout(() => {
            if (state.currentPlayer === 2 && state.gameActive && state.players[2].hand.length > INITIAL_HAND_SIZE) {
                aiDiscard();
            }
        }, 600);
    }
}

// AI å¼ƒç‰Œé€»è¾‘ï¼šä¿ç•™æ¨¡æ‹Ÿä¸‹æ£‹æ—¶é«˜åˆ†ç­–ç•¥ä¸­ç”¨åˆ°çš„æ‰‹ç‰Œï¼Œä¼˜å…ˆå¼ƒæ‰éé«˜åˆ†ç­–ç•¥ä¸­ç”¨åˆ°çš„é‡å¤çš„æ‰‹ç‰Œ
function aiDiscard() {
    if (!state.gameActive || state.currentPlayer !== 2) return;
    
    const hand = state.players[2].hand;
    if (hand.length === 0) return;

    const counts = {};
    hand.forEach((card, index) => {
        if (index === state.aiPlannedCardIndex) return;
        if (card.color !== 'red') {
            const key = `${card.color}-${card.value}`;
            counts[key] = (counts[key] || 0) + 1;
        }
    });

    let bestDiscardIndex = 0;
    let maxWeight = -Infinity;

    hand.forEach((card, index) => {
        let weight = 0;
        if (index === state.aiPlannedCardIndex) {
            weight = -60;
        } else if (card.color === 'red') {
            weight = -20;
        } else {
            const key = `${card.color}-${card.value}`;
            if (counts[key] > 1) {
                weight += 10;
            }
            let canPlace = false;
            for (let r = 0; r < BOARD_SIZE; r++) {
                for (let c = 0; c < BOARD_SIZE; c++) {
                    if (isValidMove(r, c, card)) {
                        canPlace = true;
                        break;
                    }
                }
                if (canPlace) break;
            }
            if (!canPlace) {
                weight += 10;
            }
            weight += (10 - card.value);
            randomWeight = Math.random() * 50 - 25;
            weight += randomWeight;
        }
        if (weight > maxWeight) {
            maxWeight = weight;
            bestDiscardIndex = index;
        }
    });

    const cardToDiscard = hand[bestDiscardIndex];
    console.log(`AI å¼ƒç‰Œ: ${cardToDiscard.color} ${cardToDiscard.value} (æƒé‡: ${maxWeight})`);

    if (state.aiPlannedCardIndex !== null && bestDiscardIndex < state.aiPlannedCardIndex) {
        state.aiPlannedCardIndex--;
    } else if (bestDiscardIndex === state.aiPlannedCardIndex) {
        state.aiPlannedCardIndex = null;
    }
    
    state.discardedCard = { ...cardToDiscard };
    state.players[2].hand.splice(bestDiscardIndex, 1);
    state.selectedCardIndex = null;
    
    renderHands();
    renderDiscardSquare();
    
    if (state.players[2].hand.length <= INITIAL_HAND_SIZE) {
        state.aiPlannedCardIndex = null;
        endTurn();
    } else {
        setTimeout(() => aiDiscard(), 100);
    }
}

// ç»“æŸå›åˆé€»è¾‘
function endTurn() {
    // é‡ç½®å›åˆçŠ¶æ€
    state.placedThisTurn = false;
    state.selectedCardIndex = null;
    
    // åˆ‡æ¢ç©å®¶
    state.currentPlayer = state.currentPlayer === 1 ? 2 : 1;
    
    if (state.currentPlayer === 1) {
        state.round++;
    }
    
    // æ–°å›åˆå¼€å§‹ï¼šå‘ä¸€å¼ ç‰Œï¼Œæš‚æ—¶å–æ¶ˆ
    drawCard(state.currentPlayer);
    drawCard(state.currentPlayer);    
    
    updateUI();
    renderHands(); 

    // å¦‚æœåˆ‡æ¢åˆ°äº† AI ç©å®¶ï¼Œè§¦å‘ AI è¡ŒåŠ¨
    if (state.currentPlayer === 2 && state.isAIEnabled) {
        runAIAction();
    }
}

// ä¿®æ”¹å‘ç‰Œé€»è¾‘ï¼šä»ç‰Œå †å–ç‰Œ
function drawCard(playerId) {
    // å½“æ‰‹ç‰Œæ•°é‡å¤§äºç­‰äº20æ—¶ï¼Œä¸æŠ“ç‰Œ
    if (state.players[playerId].hand.length >= 20) return;
    
    if (state.deck.length > 0) {
        state.players[playerId].hand.push(state.deck.pop());
        sortHand(playerId);
    }
}

// æ‰‹ç‰Œæ’åºï¼šæŒ‰èŠ±è‰²é¡ºåºå’Œæ•°å€¼ä»å°åˆ°å¤§
function sortHand(playerId) {
    const colorOrder = {
        'yellow': 1,
        'brown': 2,
        'blue': 3,
        'green': 4,
        'red': 5
    };
    
    state.players[playerId].hand.sort((a, b) => {
        if (colorOrder[a.color] !== colorOrder[b.color]) {
            return colorOrder[a.color] - colorOrder[b.color];
        }
        return a.value - b.value;
    });
}

// é‡æ–°å¼€å§‹
restartBtn.addEventListener('click', () => {
    if(confirm("ç¡®å®šè¦é‡æ–°å¼€å§‹æ¸¸æˆå—ï¼Ÿ")) {
        initGame();
    }
});

// å¯åŠ¨
initGame();
updateLanguageUI();


</script>
